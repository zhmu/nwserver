/*-
 * SPDX-License-Identifier: GPL-3.0-or-later
 *
 * Copyright (c) 2022 Rink Springer <rink@rink.nu>
 * For conditions of distribution and use, see LICENSE file
 */

/*
 *
 * This code is inspired by mars_nwe's nwcrypt.c, which credits the origin as
 * follows:
 *
 * This code has been taken from DDJ 11/93, from an
 * article by Pawel Szczerbina.
 *
 * Password encryption routines follow.
 * Converted to C from Barry Nance's Pascal
 * prog published in the March -93 issue of Byte.
 *
 * Adapted to be useable for ncpfs by
 * Volker Lendecke <lendecke@namu01.gwdg.de> in
 * October 1995.
 *
 * Stolen to be useable for mars_nwe by
 * Martin Stover <mstover@freeway.de> in
 * Dezember 1995.
 */
use byteorder::{BigEndian, ByteOrder};

const SHUFFLE1_NIBBLE_TABLE: [ u8; 256 ] = [
    0x7, 0x8, 0x0, 0x8, 0x6, 0x4, 0xe, 0x4, 0x5, 0xc, 0x1, 0x7, 0xb, 0xf, 0xa, 0x8,
    0xf, 0x8, 0xc, 0xc, 0x9, 0x4, 0x1, 0xe, 0x4, 0x6, 0x2, 0x4, 0x0, 0xa, 0xb, 0x9,
    0x2, 0xf, 0xb, 0x1, 0xd, 0x2, 0x1, 0x9, 0x5, 0xe, 0x7, 0x0, 0x0, 0x2, 0x6, 0x6,
    0x0, 0x7, 0x3, 0x8, 0x2, 0x9, 0x3, 0xf, 0x7, 0xf, 0xc, 0xf, 0x6, 0x4, 0xa, 0x0,
    0x2, 0x3, 0xa, 0xb, 0xd, 0x8, 0x3, 0xa, 0x1, 0x7, 0xc, 0xf, 0x1, 0x8, 0x9, 0xd,
    0x9, 0x1, 0x9, 0x4, 0xe, 0x4, 0xc, 0x5, 0x5, 0xc, 0x8, 0xb, 0x2, 0x3, 0x9, 0xe,
    0x7, 0x7, 0x6, 0x9, 0xe, 0xf, 0xc, 0x8, 0xd, 0x1, 0xa, 0x6, 0xe, 0xd, 0x0, 0x7,
    0x7, 0xa, 0x0, 0x1, 0xf, 0x5, 0x4, 0xb, 0x7, 0xb, 0xe, 0xc, 0x9, 0x5, 0xd, 0x1,
    0xb, 0xd, 0x1, 0x3, 0x5, 0xd, 0xe, 0x6, 0x3, 0x0, 0xb, 0xb, 0xf, 0x3, 0x6, 0x4,
    0x9, 0xd, 0xa, 0x3, 0x1, 0x4, 0x9, 0x4, 0x8, 0x3, 0xb, 0xe, 0x5, 0x0, 0x5, 0x2,
    0xc, 0xb, 0xd, 0x5, 0xd, 0x5, 0xd, 0x2, 0xd, 0x9, 0xa, 0xc, 0xa, 0x0, 0xb, 0x3,
    0x5, 0x3, 0x6, 0x9, 0x5, 0x1, 0xe, 0xe, 0x0, 0xe, 0x8, 0x2, 0xd, 0x2, 0x2, 0x0,
    0x4, 0xf, 0x8, 0x5, 0x9, 0x6, 0x8, 0x6, 0xb, 0xa, 0xb, 0xf, 0x0, 0x7, 0x2, 0x8,
    0xc, 0x7, 0x3, 0xa, 0x1, 0x4, 0x2, 0x5, 0xf, 0x7, 0xa, 0xc, 0xe, 0x5, 0x9, 0x3,
    0xe, 0x7, 0x1, 0x2, 0xe, 0x1, 0xf, 0x4, 0xa, 0x6, 0xc, 0x6, 0xf, 0x4, 0x3, 0x0,
    0xc, 0x0, 0x3, 0x6, 0xf, 0x8, 0x7, 0xb, 0x2, 0xd, 0xc, 0x6, 0xa, 0xa, 0x8, 0xd
];

const SHUFFLE_KEYS: [ u8; 32 ] = [
    0x48, 0x93, 0x46, 0x67, 0x98, 0x3d, 0xe6, 0x8d,
    0xb7, 0x10, 0x7a, 0x26, 0x5a, 0xb9, 0xb1, 0x35,
    0x6b, 0x0f, 0xd5, 0x70, 0xae, 0xfb, 0xad, 0x11,
    0xf4, 0x47, 0xdc, 0xa7, 0xec, 0xcf, 0x50, 0xc0
];

fn shuffle1(temp: &[u8; 32]) -> [ u8; 16 ] {
    let mut shuffeled_temp = [ 0u8; 32 ];
    shuffeled_temp.copy_from_slice(temp);

    let mut b4: u8 = 0;
    for _ in 0..2 {
        for s in 0..32 as usize {
            let index = (s + b4 as usize) & 31;
            let b3 = shuffeled_temp[s].wrapping_add(b4) ^ shuffeled_temp[index].wrapping_sub(SHUFFLE_KEYS[s]);
            b4 = b4.wrapping_add(b3);
            shuffeled_temp[s] = b3;
        }
    }

    let mut result = [ 0u8; 16 ];
    for (n, v) in result.iter_mut().enumerate() {
        *v =
             SHUFFLE1_NIBBLE_TABLE[shuffeled_temp[2 * n    ] as usize] |
            (SHUFFLE1_NIBBLE_TABLE[shuffeled_temp[2 * n + 1] as usize] << 4);
    }
    result
}

fn shuffle(key: &[u8], buf: [u8; 16]) -> [u8; 16] {
    let mut buf_len = buf.len();
    while buf_len > 0 && buf[buf_len - 1] == 0 {
        buf_len -= 1;
    }

    let mut temp = [ 0u8; 32 ];
    if buf_len > 0 {
        let mut n: usize = 0;
        for (index, v) in temp.iter_mut().enumerate() {
            if n < buf_len {
                *v ^= buf[n];
                n += 1;
            } else {
                *v ^= SHUFFLE_KEYS[index];
                n = 0;
            }
        }
    }

    for (index, v) in temp.iter_mut().enumerate() {
        *v ^= key[index & 3];
    }

    shuffle1(&temp)
}

pub fn encrypt(fra: &[u8], buf: [u8; 16]) -> [u8; 8] {
    let k = shuffle(&fra[0..4], buf);
    let l = shuffle(&fra[4..8], buf);

    let mut result = [ 0u8; 8 ];
    for (index, v) in result.iter_mut().enumerate() {
        let a = k[index] ^ l[15 - index];
        let b = k[15 - index] ^ l[index];
        *v = a ^ b;
    }
    result
}

const NEW_SHUFFLE: [ u8; 256 + 16 ] = [
    0x0f, 0x08, 0x05, 0x07, 0x0c, 0x02, 0x0e, 0x09,
    0x00, 0x01, 0x06, 0x0d, 0x03, 0x04, 0x0b, 0x0a,
    0x02, 0x0c, 0x0e, 0x06, 0x0f, 0x00, 0x01, 0x08,
    0x0d, 0x03, 0x0a, 0x04, 0x09, 0x0b, 0x05, 0x07,

    0x05, 0x02, 0x09, 0x0f, 0x0c, 0x04, 0x0d, 0x00,
    0x0e, 0x0a, 0x06, 0x08, 0x0b, 0x01, 0x03, 0x07,
    0x0f, 0x0d, 0x02, 0x06, 0x07, 0x08, 0x05, 0x09,
    0x00, 0x04, 0x0c, 0x03, 0x01, 0x0a, 0x0b, 0x0e,

    0x05, 0x0e, 0x02, 0x0b, 0x0d, 0x0a, 0x07, 0x00,
    0x08, 0x06, 0x04, 0x01, 0x0f, 0x0c, 0x03, 0x09,
    0x08, 0x02, 0x0f, 0x0a, 0x05, 0x09, 0x06, 0x0c,
    0x00, 0x0b, 0x01, 0x0d, 0x07, 0x03, 0x04, 0x0e,

    0x0e, 0x08, 0x00, 0x09, 0x04, 0x0b, 0x02, 0x07,
    0x0c, 0x03, 0x0a, 0x05, 0x0d, 0x01, 0x06, 0x0f,
    0x01, 0x04, 0x08, 0x0a, 0x0d, 0x0b, 0x07, 0x0e,
    0x05, 0x0f, 0x03, 0x09, 0x00, 0x02, 0x06, 0x0c,

    0x05, 0x03, 0x0c, 0x08, 0x0b, 0x02, 0x0e, 0x0a,
    0x04, 0x01, 0x0d, 0x00, 0x06, 0x07, 0x0f, 0x09,
    0x06, 0x00, 0x0b, 0x0e, 0x0d, 0x04, 0x0c, 0x0f,
    0x07, 0x02, 0x08, 0x0a, 0x01, 0x05, 0x03, 0x09,

    0x0b, 0x05, 0x0a, 0x0e, 0x0f, 0x01, 0x0c, 0x00,
    0x06, 0x04, 0x02, 0x09, 0x03, 0x0d, 0x07, 0x08,
    0x07, 0x02, 0x0a, 0x00, 0x0e, 0x08, 0x0f, 0x04,
    0x0c, 0x0b, 0x09, 0x01, 0x05, 0x0d, 0x03, 0x06,

    0x07, 0x04, 0x0f, 0x09, 0x05, 0x01, 0x0c, 0x0b,
    0x00, 0x03, 0x08, 0x0e, 0x02, 0x0a, 0x06, 0x0d,
    0x09, 0x04, 0x08, 0x00, 0x0a, 0x03, 0x01, 0x0c,
    0x05, 0x0f, 0x07, 0x02, 0x0b, 0x0e, 0x06, 0x0d,

    0x09, 0x05, 0x04, 0x07, 0x0e, 0x08, 0x03, 0x01,
    0x0d, 0x0b, 0x0c, 0x02, 0x00, 0x0f, 0x06, 0x0a,
    0x09, 0x0a, 0x0b, 0x0d, 0x05, 0x03, 0x0f, 0x00,
    0x01, 0x0c, 0x08, 0x07, 0x06, 0x04, 0x0e, 0x02,

    0x03, 0x0e, 0x0f, 0x02, 0x0d, 0x0c, 0x04, 0x05,
    0x09, 0x06, 0x00, 0x01, 0x0b, 0x07, 0x0a, 0x08,
];

fn shuffle_old_password(buf: &mut [u8]) {
    let ch = buf[0] << 4;
    for j in 0..7 {
        buf[j] = (buf[j + 1] << 4)| ((buf[j] >> 4) & 0x0f);
    }
    buf[7] = ch | ((buf[7] >> 4) & 0x0f);
}

fn generate_inverse_shuffle_table() -> [u8; 256 + 16] {
    const SLICE_SIZE: usize = 16;
    let mut table = [ 0u8; 256 + SLICE_SIZE ];
    for i in (0..table.len()).step_by(SLICE_SIZE) {
        for j in 0..SLICE_SIZE {
            table[i + NEW_SHUFFLE[i + j] as usize] = j as u8;
        }
    }
    table
}

pub fn decrypt(oldpwd: [u8; 8], newpwd: [u8; 8]) -> [ u8; 8 ] {
    let inv_shuffle = generate_inverse_shuffle_table();

    let mut old_password_shuffled = [ 0u8; 8 ];
    old_password_shuffled.copy_from_slice(&oldpwd);

    let mut current_password = [ 0u8; 8 ];
    current_password.copy_from_slice(&newpwd);

    let mut result = [ 0u8; 8 ];
    for _ in 0..16 {
        result.fill(0);
        for j in 0..16 {
            let v = current_password[j / 2];
            let nibble_value = if (j & 1) != 0 { v >> 4 } else { v } & 0x0f;

            let n = NEW_SHUFFLE[j + 0x100];
            let new_nibble = if (n & 1) != 0 { nibble_value << 4 } else { nibble_value };
            result[(n / 2) as usize] |= new_nibble;
        }
        shuffle_old_password(&mut old_password_shuffled);

        for (index, v) in result.iter_mut().enumerate() {
            let cl = inv_shuffle[ (*v & 0x0f) as usize + index * 32];
            let ch = inv_shuffle[((*v >> 4) & 0x0f) as usize + index * 32 + 16] << 4;
            *v = (ch | cl) ^ old_password_shuffled[index];
        }
        current_password.copy_from_slice(&result);
    }
    result
}

pub fn encrypt_bindery_password(object_id: u32, password: &str) -> [u8; 16] {
    let password_bytes = password.as_bytes();
    let mut buffer = [ 0u8; 16 ];
    buffer[0..password_bytes.len()].copy_from_slice(&password_bytes);

    let mut uid = [ 0u8; 4 ];
    BigEndian::write_u32(&mut uid, object_id);
    shuffle(&uid, buffer)
}

#[cfg(test)]
mod tests {
    use crate::crypto::*;

    #[test]
    fn encrypt_1() {
        let key: [ u8; 8 ] = [ 0x12, 0x34, 0x56, 0x78, 0x9a, 0x7b, 0x44, 0x93 ];
        let data: [ u8; 16 ] = [ 0x98, 0x32, 0x35, 0x67, 0xdd, 0x2f, 0xaa, 0x80, 0xab, 0xdc, 0xb0, 0xc0, 0x1e, 0x21, 0x46, 0x34 ];
        let expected: [ u8; 8] = [ 0x2f, 0x75, 0xfd, 0xb5, 0xb5, 0xde, 0xee, 0xd3 ];
        let out = encrypt(&key, data);
        assert_eq!(out, expected);
    }

    #[test]
    fn encrypt_2() {
        let key: [ u8; 8 ] = [ 0xce, 0xcc, 0xf3, 0x6a, 0xac, 0x49, 0x55, 0x7a ];
        let data: [ u8; 16 ] = [ 0xad, 0x5c, 0x42, 0x40, 0x47, 0xc4, 0x4e, 0x11, 0x6e, 0x7e, 0xff, 0xe7, 0x6d, 0xf7, 0xb3, 0x25 ];
        let expected: [ u8; 8 ] = [ 0x23, 0xbf, 0x57, 0x8c, 0x63, 0x4f, 0x0f, 0x37 ];
        let out = encrypt(&key, data);
        assert_eq!(out, expected);
    }

    #[test]
    fn shuffle_old_password_1() {
        let mut data: [ u8; 8 ] = [ 0x01, 0x23, 0x45, 0x67, 0x89, 0x9a, 0xbc, 0xde ];
        let expected: [ u8; 8] = [ 0x30, 0x52, 0x74, 0x96, 0xa8, 0xc9, 0xeb, 0x1d ];
        shuffle_old_password(&mut data);
        assert_eq!(data, expected);
    }

    #[test]
    fn decrypt_1() {
        let data1: [ u8; 8 ] = [ 0x98, 0x32, 0x35, 0x67, 0xdd, 0x2f, 0xaa, 0x80 ];
        let data2: [ u8; 8] = [ 0xad, 0x5c, 0x42, 0x40, 0x47, 0xc4, 0x4e, 0x11 ];
        let expected: [ u8; 8 ] = [ 0x6d, 0xc9, 0xde, 0x66, 0xbd, 0x54, 0x4e, 0xc1 ];
        let out = decrypt(data1, data2);
        assert_eq!(out, expected);
    }
}
